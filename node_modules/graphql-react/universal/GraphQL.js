'use strict';

var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');

var _temp;

var mitt = require('mitt/dist/mitt');

var hashObject = require('./hashObject');

var graphqlFetchOptions = require('./private/graphqlFetchOptions');

module.exports =
  ((_temp = function GraphQL(_temp2) {
    var _this = this;

    var _ref = _temp2 === void 0 ? {} : _temp2,
      _ref$cache = _ref.cache,
      cache = _ref$cache === void 0 ? {} : _ref$cache;

    this.reload = function (exceptCacheKey) {
      _this.emit('reload', {
        exceptCacheKey: exceptCacheKey,
      });
    };

    this.reset = function (exceptCacheKey) {
      var cacheKeys = Object.keys(_this.cache);
      if (exceptCacheKey)
        cacheKeys = cacheKeys.filter(function (hash) {
          return hash !== exceptCacheKey;
        });
      cacheKeys.forEach(function (cacheKey) {
        return delete _this.cache[cacheKey];
      });

      _this.emit('reset', {
        exceptCacheKey: exceptCacheKey,
      });
    };

    this.fetch = function (_ref2, cacheKey) {
      var url = _ref2.url,
        options = _objectWithoutPropertiesLoose(_ref2, ['url']);

      var fetchResponse;
      var fetcher =
        typeof fetch === 'function'
          ? fetch
          : function () {
              return Promise.reject(
                new TypeError('Global fetch API or polyfill unavailable.')
              );
            };
      var cacheValue = {};
      var cacheValuePromise = fetcher(url, options)
        .then(
          function (response) {
            fetchResponse = response;
            if (!response.ok)
              cacheValue.httpError = {
                status: response.status,
                statusText: response.statusText,
              };
            return response.json().then(
              function (_ref3) {
                var errors = _ref3.errors,
                  data = _ref3.data;
                if (!errors && !data)
                  cacheValue.parseError = 'Malformed payload.';
                if (errors) cacheValue.graphQLErrors = errors;
                if (data) cacheValue.data = data;
              },
              function (_ref4) {
                var message = _ref4.message;
                cacheValue.parseError = message;
              }
            );
          },
          function (_ref5) {
            var message = _ref5.message;
            cacheValue.fetchError = message;
          }
        )
        .then(function () {
          _this.cache[cacheKey] = cacheValue;
          delete _this.operations[cacheKey];

          _this.emit('cache', {
            cacheKey: cacheKey,
            cacheValue: cacheValue,
            response: fetchResponse,
          });

          return cacheValue;
        });
      _this.operations[cacheKey] = cacheValuePromise;

      _this.emit('fetch', {
        cacheKey: cacheKey,
        cacheValuePromise: cacheValuePromise,
      });

      return cacheValuePromise;
    };

    this.operate = function (_ref6) {
      var operation = _ref6.operation,
        fetchOptionsOverride = _ref6.fetchOptionsOverride,
        _ref6$cacheKeyCreator = _ref6.cacheKeyCreator,
        cacheKeyCreator =
          _ref6$cacheKeyCreator === void 0 ? hashObject : _ref6$cacheKeyCreator,
        reloadOnLoad = _ref6.reloadOnLoad,
        resetOnLoad = _ref6.resetOnLoad;
      if (typeof cacheKeyCreator !== 'function')
        throw new TypeError(
          'operate() option “cacheKeyCreator” must be a function.'
        );
      if (reloadOnLoad && resetOnLoad)
        throw new TypeError(
          'operate() options “reloadOnLoad” and “resetOnLoad” can’t both be true.'
        );
      var fetchOptions = graphqlFetchOptions(operation);
      if (fetchOptionsOverride) fetchOptionsOverride(fetchOptions);
      var cacheKey = cacheKeyCreator(fetchOptions);

      var cacheValuePromise =
        _this.operations[cacheKey] || _this.fetch(fetchOptions, cacheKey);

      cacheValuePromise.then(function () {
        if (reloadOnLoad) _this.reload(cacheKey);
        else if (resetOnLoad) _this.reset(cacheKey);
      });
      return {
        cacheKey: cacheKey,
        cacheValue: _this.cache[cacheKey],
        cacheValuePromise: cacheValuePromise,
      };
    };

    var _mitt = mitt(),
      on = _mitt.on,
      off = _mitt.off,
      emit = _mitt.emit;

    this.on = on;
    this.off = off;
    this.emit = emit;
    this.cache = cache;
    this.operations = {};
  }),
  _temp);
